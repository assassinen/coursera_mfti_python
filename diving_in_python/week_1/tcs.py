# wins = [1]
# losses = [0]
#
# for N in range(2, 3):
#     d = 1
#     print(N, d)
#     while (d <= N) and (N not in wins):
#         if N-d in losses:
#             print(N, d)
#             wins.append(N)
#             d *= 2
#
#
#             # if (N not in wins):
#             #     losses.append(N)
#
# print (wins)
# print (losses)
# print("end")

# s = "HE5L1O"
# s = input()
# m = ''
# for i in s:
#     if i.isdigit():
#         m = m + i
#     elif len(m) > 0:
#         for _ in range(int(m)):
#             print(i, end= "")
#         m = ''
#     else:
#         print(i, end= "")

# Задача 1
# Петя и Вася случайно рассыпали кофейные зерна на стол. Казалось бы, просто собери их в мусор, но они по такому случаю придумали игру со следующими правилами. Петя и Вася умны, всегда ходят оптимально и поочередно. За каждый ход один игрок обязан взять степень двойки кофейных зерен со стола (1, 2, 4, 8 и тд). Выигрывает тот, кто взял последнее зернышко.
#
# Напишите программу, которая при заданном количестве кофейных зерен определяла бы победителя в этой игре.
#
# Входные данные
# Единственное натуральное число N (N \leqslant 10^{200})N(N⩽10
# 200
#  ) - количество кофейных зерен.
# Результат работы
# Если выигрывает тот, кто ходит первым, должно быть выведено «1», если второй, то «2». В случае, если выиграл первый, в следующей строке нужно вывести минимальное количество кофейных зерен, которое он должен взять в первом ходу, чтобы точно победить.


# Задача 2
# Во время контеста на летние стажировки у разработчиков закончилось свободное место на сервере и они решили оперативно сжать хранимые на сайте тексты. Они справились с задачей и воспользовались простейшим алгоритмом: подряд идущие одинаковые буквы (если их строго больше одной) заменили на число повторений + букву. Например, слово "HELLO" сжимается в "HE2LO". Пока они занимались сжатием строк, системные администраторы выделили дополнительной памяти и теперь стоит обратная задача: нужно написать программу, которая вернет строки в исходный вид.
#
# Входные данные
# Первая строка содержит строку, состоящую из заглавных латинских букв и цифр, длина строки не превышает 10^3.10
# 3
#  .
# Результат работы
# Выведите строку в несжатом виде

# Задача 3
# Валентин только познает этот мир и читает справочники по двоичной системе и нумерологии. После тщательных изысканий он решил избегать последовательностей из 0 и 1, в которых есть четыре подряд идущие единицы. Помогите Валентину определить, сколько существует последовательностей длины N, которых бы он не захотел избегать.
#
# Входные данные
# Вводится N (1 \leqslant N \leqslant 60).N(1⩽N⩽60).
# Результат работы
# Выведите число последовательностей, которых не избегает Валентин.

# n = int(input())
n  = 7
m_size = 4
multiplier = n - m_size

s_end = 2 ** n
m_value = 2 ** m_size - 1

s = set()


for i in range(s_end):
    # print(bin(i))
    for _ in range(n - m_size + 1):
    # for _ in range(n - m_size, n - m_size + 1):
    #     print(i)
        if i & (m_value << _) == m_value << _:
            s.add(i)
# for i in map(lambda x: bin(x), s):
#     print(i)
# # print(s_end - len(s))
#
# # for i in range(s_end):
# #     # print(m_value[2:])
# #     if str(bin(i)).count(m_value[2:]):
# #         s.add(i)
print(len(s))
print(s_end - len(s))

import math

x = math.factorial(7)/math.factorial(4)
print(x)

# s = 0
# max = n - m_size + 1
# for i in range(1, max):
#     one_mult = max - i
#     two_mult = i - 1
#
#     # if two_mult == -1:
#     #     two_mult = 0
#
#     # if two_mult == 0:
#     #     sm = 2 ** (max - 1)
#     # else:
#     #     sm = 2 ** (max - 1) - 2 ** (two_mult - 1)
#
#     sm = 2 ** (max - 1) - 2 ** (two_mult - 1)
#
#
#     # print(one_mult, two_mult)
#     s = s + sm
#     print(s)
#     # else:
#     #     s = s + 2 ** one_mult
#
# print(s)
# print(s_end - s)
#
# print(2 ** 0)



# r = m_size + 1
# r = 0
#
# for i in range(n - m_size + 1):
#     print(2 ** i)
#     # print(i, 2 ** (n - m_size - 1) + i)
#     rr = 2 ** i
#     r += rr
#
# print()
# print(r)
# # print(2 ** n)
# print(2 ** n - r)
# print()
# print(n, len(s) - r)
#
# print()



# s = "1101111"
# print(s.count("111"))

# Задача 4
# Представитель Tinkoff.ru должен отвезти карточки по N пунктам. Он смотрит для каждой пары пунктов A и B, существуют ли общественный транспорт без пересадок, чтобы добраться из A в B (причем существование пути из A в B не гарантирует, что существует путь из B в A). Существует ли такой набор пунктов, по которым можно кататься по кругу?
#
# Входные данные
# Первая строка содержит N (1 \leqslant N \leqslant 100).N(1⩽N⩽100).
# Следующие NN строк содержат по NN чисел каждая: 0 или 1. jj-ое число в ii-ой строке равно 1 тогда и только тогда, когда существует транспорт без пересадок, идущий из пункта ii в пункт j.j. Из пункта ii в пункт ii транспорта без пересадок нет ни для какого i.i.
# Результат работы
# Выведите 1, если существует такой набор пунктов, по которым можно кататься по кругу, и 0 в ином случае.

# Задача 5
# У одного из программистов Tinkoff.ru сегодня день рождения. Его коллеги собрались на кухне, горя желанием резать праздничный круглый плоский торт. Но нельзя просто так взять и разрезать торт, хотелось бы обойтись как можно меньшим количеством разрезов.
#
# Входные данные
# Первая строка содержит число коллег N (1 \leqslant N \leqslant 600000).N(1⩽N⩽600000).
# Результат работы
# Единственное целое число - минимальное количество прямых разрезов, которыми можно поделить торт таким образом, чтобы всем программистам досталось хотя бы по кусочку. Кусочки не обязательно должны быть равными.

# import math
#
# n = int(input())
# i = 1
# is_run = True
# while is_run:
#     r = math.pow(2, i)
#     if r > n:
#         print(i)
#         is_run = False
#     else:
#         i += 1
